{
  "audited_project_id": 7,
  "project_name": "MantaNetwork",
  "auditor": "Veridise",
  "audit_link": "https://github.com/Manta-Network/Atlantic-Audits/blob/main/Atlantic-Veridise-Chain.pdf",
  "findings": [
    {
      "title": "Static fee charged despite dynamic storage accesses",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "parachain-staking/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Medium",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Bad Extrinsic Weight",
      "vulnerability_class_scout": "Weight Management",
      "description": "4.1.1 V-MANC-VUL-001: Static fee charged despite dynamic storage accesses\n\nSeverity: Medium\nType: Bad Extrinsic Weight\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): parachain-staking/lib.rs\nLocation(s): go_online, go_offline, candidate_bond_more\n\nBlockchain computations must have appropriate fees to prevent network congestion. For substrate extrinsics, these fees are set by computing an associated weight for the operation where the weight is intended to capture the maximum computational cost. As reads from and writes to storage are expensive, these weights should consider the number of these operations that are performed. The following extrinsics, however, have a fixed weight despite requiring a dynamic number of reads or writes due to insert or remove operations being performed on CandidatePool.\n\n- go_online\n- go_offline\n- candidate_bond_more\n- execute_candidate_bond_less\n- delegate\n- execute_leave_delegators\n- delegator_bond_more\n- execute_delegation_request\n- schedule_leave_delegators\n- schedule_delegator_bond_less\n- cancel_leave_delegators\n\nAlso note that similar functions in the same pallet, such as schedule_leave_candidates charge the users dynamic fees. An example can be seen in Snippet 4.1.\n\nImpact: As the size of the CandidatePool grows, the cost of insert and remove will increase linearly since vector inserts in Rust are linear in the size of the vector. This allows malicious actors to add many candidates to the pool for a fixed monetary cost despite an increasing computational cost. If the size of the pool becomes too large, this could effectively create a DoS.\n\nRecommendation: Similar to schedule_leave_candidates, calculate the weights dynamically rather than charging a fixed cost.\n\nDeveloper Response: The developers have acknowledged the issue and are determining how to address it.\n\nSnippet 4.1: go_offline calls remove on the CandidatePool but charges users a fixed weight in WeightInfo::go_offline\n\n#[pallet::call_index(12)]\n#[pallet::weight(<T as Config>::WeightInfo::go_offline())]\n/// Temporarily leave the set of collator candidates without unbonding\npub fn go_offline(origin: OriginFor<T>) -> DispatchResultWithPostInfo {\n   let collator = ensure_signed(origin)?;\n   let mut state = <CandidateInfo<T>>::get(&collator).ok_or(Error::<T>::CandidateDNE)?;\n   ensure!(state.is_active(), Error::<T>::AlreadyOffline);\n   state.go_offline();\n   let mut candidates = <CandidatePool<T>>::get();\n   if candidates.remove(&Bond::from_owner(collator.clone())) {\n      <CandidatePool<T>>::put(candidates);\n   }\n   <CandidateInfo<T>>::insert(&collator, state);\n   Self::deposit_event(Event::CandidateWentOffline { candidate: collator });\n   Ok(().into())\n}",
      "description_summary": "Fixed fees are charged for dynamic storage operations, potentially leading to DoS as CandidatePool size grows.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Users can use any previously seen Merkle root",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/manta-pay/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Medium",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Hash Collision",
      "vulnerability_class_scout": "Dependency",
      "description": "4.1.2 V-MANC-VUL-002: Users can use any previously seen Merkle root\n\nSeverity: Medium\nType: Hash Collision\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): pallets/manta-pay/src/lib.rs\nLocation(s): has_matching_utxo_accumulator_output\n\nThe MantaPay protocol maintains a Merkle tree on the ledger where the leaves of the ledger are the hashes of the UTXOs generated during the protocol’s lifetime. In order to spend a UTXO, users must supply a ZK proof that the UTXO belongs to the Merkle tree on the ledger. The membership proof takes as input the root of the Merkle tree (public input), the inner node hashes (private inputs), and proves that the root can be derived from the inner node hashes and leaf.\n\nIdeally, the ledger would check that the root provided is equal to the latest root on-chain. However, this isn’t done in practice as the transaction could easily be front-runned since every transaction changes the root. Instead, the ledger maintains a set of all previously generated roots and just checks that the root provided belongs to that set.\n\nHowever, by allowing the root provided by the user to be any previously generated root, an attacker simply needs to find a hash collision with any previously generated root to steal assets. The likelihood of finding a collision grows quadratically with the number of previously seen hashes. In particular, given an output size of b bits and n previously generated hashes, the likelihood of finding a collision with any of the n hashes is approximately n^2/2^(b+1).\n\nThe current version of the Protocol uses the Poseidon hash function, which produces 255-bit hashes and, in theory, should be safe even with billions of previously seen roots. However, this is contingent on the safety of the Poseidon hash. While there has been a significant amount of research and analysis conducted on the function, including various attacks and optimizations, there is no formal proof of its security and correctness, let alone any proofs about concrete implementations.\n\nImpact: Storing all previously seen roots significantly increases the likelihood of collisions. If any attack or weakness is found in the Poseidon hash, this can be an additional means of attacking the protocol.\n\nRecommendation: There are a few ways to mitigate this. Protocols like Semaphore maintain a timeout period TIMEOUT and associate each root with a timestamp indicating when it was created. Any root created before now() - TIMEOUT is rejected. Another option is to only store the N previously generated roots and only allow a root if it belongs to the set of N previously generated roots. The latter option would have the additional benefit of not needing to store every root on-chain.\n\nDeveloper Response: The developers acknowledged the issue and will either use a timestamp or only maintain the N previously generated roots.",
      "description_summary": "Allowing any previously seen Merkle root increases the risk of hash collisions, potentially allowing asset theft.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "MantaPay weights calculated with a small database",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/manta-pay/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Medium",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Bad Extrinsic Weight",
      "vulnerability_class_scout": "Weight Management",
      "description": "4.1.3 V-MANC-VUL-003: MantaPay weights calculated with a small database\n\nSeverity: Medium\nType: Bad Extrinsic Weight\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): pallets/manta-pay/src/lib.rs\nLocation(s): to_private, to_public, private_transfer\n\nTransactions to_public, to_private, and private_transfer take as input nullifiers and membership proofs and generate UTXOs. These UTXOs are then added to a Merkle tree on the ledger.\n\nMantaPay shards this Merkle tree into 256 buckets where each bucket has its own Merkle tree. Instead of storing the entire tree at each bucket, the Ledger just stores the last path added to the tree. When adding a UTXO, the Ledger first computes its corresponding bucket, then computes the new path pointing to that UTXO, and finally adds that path to the bucket.\n\nComputing the new path should take time proportional to log(n) where n is the size of the Merkle Tree. The current benchmarking scheme only covers cases where the previous path is small, i.e., at most size 1. However, if the number of transactions gets large, on the order of hundreds of millions or billions, then the size of the path can get to 24-28 (taking shards into account). If the tree grows to this size, this means each execution of the extrinsic will perform 24-28 hashes, multiplied by the number of UTXOs to be added.\n\nThe benchmarking scheme should take into account the size of the tree to ensure that the existing weights are sufficient to offset the computation of the new Merkle tree path.\n\nImpact: Setting the weight too low can allow users to perform a large number of transactions with little cost, potentially allowing malicious users to launch a DoS attack.\n\nRecommendation: There are several ways to address this. One strategy is to take an additional parameter corresponding to the logarithm of the Merkle Tree's size on the ledger. The weight charged can be proportional to this value. In the implementation, this value (technically 2^value) can be compared against the actual size, and the transaction will only proceed if it is larger than or equal to the actual size.\n\nAnother strategy is to benchmark the pallets by taking into account the tree's size. If MantaPay is expected not to exceed more than a billion transactions, then the pallet could be benchmarked assuming the current path length is around 24-28.\n\nDeveloper Response: The developers acknowledged that the weights should be recalculated with a more saturated database.",
      "description_summary": "Inadequate benchmarking of weights for MantaPay's Merkle tree could lead to DoS attacks as the tree grows.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Total supply of native assets can exceed the set limit",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/asset-manager/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Medium",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Logic Error",
      "vulnerability_class_scout": "Business Logic",
      "description": "4.1.4 V-MANC-VUL-004: Total supply of native assets can exceed the set limit\n\nSeverity: Medium\nType: Logic Error\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): pallets/asset-manager/src/lib.rs\nLocation(s): mint_asset\n\nOne invariant underlying the correctness of MantaPay is that the total supply of an asset cannot exceed the maximum amount that can be held in a particular account. This is because MantaPay uses a dedicated account A to store the value of all the private assets. As such, A should, in principle, be able to hold all the supply in the case where all of that asset is privatized.\n\nIn more detail, when privatizing a user’s public assets (via to_private), MantaPay constructs opaque UTXOs to encode the amount privatized, and then transfers those public assets into A. This transfer is expected not to fail because of the invariant described above. However, we found a case where the transfer can fail.\n\nManta enforces this invariant for NonNative assets because every time an asset is minted into an account, the total supply is increased. If the total supply would exceed the maximum that can be held in an account, the mint fails with the error Overflow. However, there is no such check for Native assets. Thus, if the total supply of Native assets exceeds the maximum that can be held in an account, u128::MAX, then to_private calls that should succeed can fail if the amount held in A is close to the maximum allowed. This is demonstrated in Snippet 4.2.\n\nImpact: By not constraining the amount of Native assets to be less than the maximum amount that can be held in an account, to_private transactions that should succeed will fail.\n\nRecommendation: We recommend a similar check be done for Native assets as is done for NonNative assets to enforce that the total supply cannot exceed the maximum that can be held in a given account.\n\nDeveloper Response: The developers have acknowledged the issue and are determining how to address it.\n\nSnippet 4.2: Failed to_private due to count of native assets exceeding u128::MAX\n\n#[test]\nfn public_account_issue() {\nlet mut rng = OsRng;\nnew_test_ext().execute_with(|| {\nlet asset_id = NATIVE_ASSET_ID;\nlet value = 1000u128;\nlet id = NATIVE_ASSET_ID;\nlet metadata = AssetRegistryMetadata {\nmetadata: AssetStorageMetadata {\nname: b\"Calamari\".to_vec(),\nsymbol: b\"KMA\".to_vec(),\ndecimals: 12,\nis_frozen: false,\n},\nmin_balance: TEST_DEFAULT_ASSET_ED2,\nis_sufficient: true,\n};\nassert_ok!(MantaAssetRegistry::create_asset(\nid, metadata.into(), TEST_DEFAULT_ASSET_ED2,\ntrue\n));\nassert_ok!(FungibleLedger::<Test>::deposit_minting(id, &ALICE, 2*value));\nassert_ok!(FungibleLedger::<Test>::deposit_minting(id, &MantaPay::account_id(), u128::MAX));\nlet mut utxo_accumulator = UtxoAccumulator::new(UTXO_ACCUMULATOR_MODEL.clone());\nlet spending_key = rng.gen();\nlet address = PARAMETERS.address_from_spending_key(&spending_key);\nlet mut authorization =\nAuthorization::from_spending_key(&PARAMETERS, &spending_key, &mut rng);\nlet asset_0 = Asset::new(Fp::from(asset_id), value);\nlet (to_private_0, pre_sender_0) = ToPrivate::internal_pair(\n&PARAMETERS, &mut authorization.context,\naddress, asset_0,\nDefault::default(), &mut rng,\n);\nlet to_private_0 = to_private_0\n.into_post(\nFullParametersRef::new(&PARAMETERS, utxo_accumulator.model()),\n&PROVING_CONTEXT.to_private,\nNone, Vec::new(), &mut rng,\n)\n.expect(\"Unable to build TO_PRIVATE proof.\")\n.expect(\"Did not match transfer shape.\");\nassert_ok!(MantaPay::to_private(\nMockOrigin::signed(ALICE),\nPalletTransferPost::try_from(to_private_0).unwrap()\n));\n}\n}\n",
      "description_summary": "Native asset supply can exceed the maximum limit for an account, causing to_private transactions to fail.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Missing updates in update_asset_metadata",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/asset-manager/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Medium",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Logic Error",
      "vulnerability_class_scout": "Business Logic",
      "description": "4.1.5 V-MANC-VUL-005: Missing updates in update_asset_metadata\n\nSeverity: Medium\nType: Logic Error\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): pallets/asset-manager/src/lib.rs\nLocation(s): update_asset_metadata\n\nManta Chain has an asset-manager pallet responsible for registering and minting assets. Each asset has a unique id and is associated with various metadata like a name, symbol, decimal places, etc. One important metadata is called min_balance. To store an account with some quantity of assets on the ledger, it must have more than min_balance quantity. This metadata is also used when validating transfers.\n\nIn particular, many asset transfers take an “existential parameter” as input, called KeepAlive, which decides what to do if the transfer would take the account’s balance (with respect to the asset) below min_balance. If KeepAlive is set, the transfer will fail if the amount goes below the min_balance. If it is not set, other configurations come into play, and the account may be removed and the remaining balance burned.\n\nThe asset-manager pallet exposes an extrinsic called update_asset_metadata, which takes as input the new metadata for that asset and updates the ledger to associate the asset with that metadata. While the implementation took a new min_balance as input, it did not update the ledger to associate the asset with this metadata.\n\nAdditionally, this API also took as input a new value for the metadata is_sufficient, but similarly did not update the ledger to associate the asset with this metadata.\n\nImpact: While it is rare for the min_balance to be changed, it is sometimes necessary if it was originally set too high, for example. The current API made it appear that min_balance could be changed, so users might think the min_balance was changed when, in fact, it wasn’t.\n\nRecommendation: The main issue with this extrinsic is its interface makes it appear as though the metadata min_balance and is_sufficient could be changed when it actually didn’t. Either the API should be changed to only take the metadata that should be changed, or it should appropriately update min_balance and is_sufficient.\n\nDeveloper Response: The developers acknowledged this issue and are discussing two possible fixes. The first is to update both parameters in the asset pallet, and the second is to change the interface to prevent updating the min_balance or is_sufficient parameters.",
      "description_summary": "update_asset_metadata does not apply updates to min_balance and is_sufficient metadata as expected.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "No slashing mechanism for collators",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "parachain-staking",
          "lines": null
        }
      ],
      "reported_impact": "Medium",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Consensus",
      "vulnerability_class_scout": "Business Logic",
      "description": "4.1.6 V-MANC-VUL-006: No slashing mechanism for collators\n\nSeverity: Medium\nType: Consensus\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): parachain-staking\nLocation(s): N/A\n\nProof of Stake blockchains often have a slashing mechanism to detect poorly performing stakers and punish them. Typically, a significant portion of the staker’s stake is taken by the chain as punishment for poor performance.\n\nCurrently, Manta Chain does not have any slashing mechanism. Instead, it uses a combination of social pressure and manual slashing to incentivize good behavior. Specifically, when the owners detect a poorly performing collator, they contact the collator over Discord and warn them of the poor performance. If their performance does not improve, the owners manually slash the collator’s funds.\n\nWhile this approach may work when the blockchain is small, it will be challenging to enforce as the chain grows. Therefore, we recommend that Manta Chain implement a slashing mechanism.\n\nImpact: Manta Chain’s current method of using social pressure will only work with a small set of trusted collators. However, as the chain expands, this mechanism is unlikely to sufficiently incentivize collators to perform well.\n\nRecommendation: We recommend that Manta Chain establish a slashing mechanism to implement if/when the current process becomes inadequate.\n\nDeveloper Response: The developers acknowledged the lack of a slashing mechanism and plan to include one in the future if/when the current process stops working.",
      "description_summary": "No automated slashing mechanism exists to penalize poorly performing collators, relying on social pressure and manual intervention.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Collators given full rewards regardless of quality",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/parachain-staking/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Medium",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Consensus",
      "vulnerability_class_scout": "Business Logic",
      "description": "4.1.7 V-MANC-VUL-007: Collators given full rewards regardless of quality\n\nSeverity: Medium\nType: Consensus\nCommit: 45ba60e1d\nStatus: Open\n\nFile(s): pallets/parachain-staking/src/lib.rs\nLocation(s): pay_one_collator_reward\n\nManta Chain rewards collators by first allocating a fixed number of points (20) for every block they author and then giving the collator a fixed percentage of those allocated points as rewards. However, there is no check on the quality of the blocks authored by the collator: an empty block will result in just as many rewards as a full block.\n\nCurrently, Manta relies on the owners to monitor the blocks on-chain and manually punish collators who perform poorly. However, as the chain grows, this misbehavior may not be easy to detect.\n\nOne relatively simple way to address this issue is to adjust the reward system to incentivize high quality blocks.\n\nImpact: Collators can effectively steal funds from Manta by authoring low-quality blocks (i.e., empty or partial blocks) and reaping full rewards.\n\nRecommendation: We recommend the developers adjust the rewards system to either reward the collators for high-quality blocks or punish them for authoring poor ones.\n\nDeveloper Response: TBD",
      "description_summary": "Collators receive full rewards regardless of block quality, allowing low-quality blocks to earn the same as high-quality ones.",
      "reported_status": "Open",
      "is_substrate_finding": true
    },
    {
      "title": "Missing validation in pull_ledger_diff",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/manta-pay/src/lib.rs",
          "lines": [593]
        }
      ],
      "reported_impact": "Low",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Data Validation",
      "vulnerability_class_scout": "Error Handling and Validation",
      "description": "4.1.8 V-MANC-VUL-008: Missing validation in pull_ledger_diff\n\nSeverity: Low\nType: Data Validation\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): pallets/manta-pay/src/lib.rs\nLocation(s): Line 593\n\npull_ledger_diff takes as input a Checkpoint, which is a struct with two fields: receiver_index and sender_index. It pulls sender and receiver data from the ledger, starting at sender_index (resp. receiver_index) up to at most sender_index + PULL_MAX_SENDER_UPDATE_SIZE (resp. receiver_index + PULL_MAX_RECEIVER_UPDATE_SIZE). However, there is no check to ensure that this sum cannot overflow for both the sender and receiver index in pull_senders, pull_receivers, pull_senders_for_shard, and pull_receivers_for_shard.\n\nImpact: If the code is compiled without the --release flag, a malicious user could crash the node by passing in bad values. If it is built with --release, the call will be reported as successful and no senders or receivers will be returned. However, if a benign end user calls the API with incorrect indexes, it might be preferable to return an Error informing them that the index is invalid.\n\nRecommendation: We recommend adding bounds checks for safety and to return an Error.\n\nDeveloper Response: The developers are aware and agree that it would be better to check and return an error.",
      "description_summary": "Missing bounds checks in pull_ledger_diff could lead to overflow, potentially crashing the node.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "increase_count_of_associated_assets can overflow",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/asset-manager/src/lib.rs",
          "lines": [590]
        }
      ],
      "reported_impact": "Low",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Logic Error",
      "vulnerability_class_scout": "Arithmetic",
      "description": "4.1.9 V-MANC-VUL-009: increase_count_of_associated_assets can overflow\n\nSeverity: Low\nType: Logic Error\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): pallets/asset-manager/src/lib.rs\nLocation(s): Line 590\n\nThe asset_manager pallet maintains a mapping of paraids to a count of assets associated with that paraid. Each paraid can be associated with at most u32::MAX assets. When registering an asset or moving its location, the pallet calls increase_count_of_associated_assets, which takes as input a paraid and increments the number of assets associated with that paraid. However, this function does not check whether increasing the number of assets will result in an overflow.\n\nImpact: If the runtime is compiled using --debug, this can crash the node. However, if built under --release, the asset count will go to zero.\n\nRecommendation: Make this function check if the addition will result in an overflow, i.e., check if the current count is u32::MAX and return an error.\n\nDeveloper Response: Acknowledged",
      "description_summary": "increase_count_of_associated_assets lacks overflow check, risking node crash or reset to zero in certain cases.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Account checks are incorrect",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/manta-pay/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Low",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Logic Error",
      "vulnerability_class_scout": "Business Logic",
      "description": "4.1.10 V-MANC-VUL-010: Account checks are incorrect.\n\nSeverity: Low\nType: Logic Error\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): pallets/manta-pay/src/lib.rs\nLocation(s): check_sink_accounts, check_source_accounts\n\nWhen validating a transaction, the source and sink accounts are checked by check_sink_accounts and check_source_accounts. These functions iterate over pairs (account, value) and check that value can be safely deposited (withdrawn) from account. The logic is correct only if every account appears in at most one pair. While this is fine for the current APIs, if the APIs change to allow multiple sink or multiple source accounts, then this code needs to be refactored or the uniqueness needs to be enforced elsewhere.\n\nImpact: Currently there is no impact since the current APIs only allow one account for the source and sink accounts.\n\nRecommendation: To be safe, we recommend adding an additional check in the validation step to ensure the accounts are distinct for both sources and sinks.\n\nDeveloper Response: The developers acknowledged the issue and plan to add a check during validation to ensure that the accounts are distinct.",
      "description_summary": "Account checks in transaction validation assume unique accounts, which may lead to issues if APIs change to allow multiple accounts.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Unstaked user may be selected as collator",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "parachain-staking/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Low",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Logic Error",
      "vulnerability_class_scout": "Business Logic",
      "description": "4.1.11 V-MANC-VUL-011: Unstaked user may be selected as collator\n\nSeverity: Low\nType: Logic Error\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): parachain-staking/lib.rs\nLocation(s): select_top_candidates\n\nParachains use collators to combine transactions into blocks that are then checked by Validators on the relay chain. Notably, this allows collators to remain relatively untrusted as validators ensure blocks are created correctly. On Manta’s chain, collators are selected from a group of staked users who receive rewards for creating blocks. Requiring that collators be staked provides additional security guarantees as, if a collator misbehaves (e.g., submits no blocks for validation, submits multiple conflicting blocks), governance can step in and slash the user’s staked funds. As such, unstaked collators have less incentive to maintain parachain stability and should be avoided.\n\nHowever, in the collator selection process, if no sufficiently staked collator can be found, collators from the previous round will be selected. As there is no validation on the current state of the previous collators’ stake, this could select unstaked validators who lack the incentive to ensure network stability.\n\nHere is a simple test case demonstrating this:\n\n#[test]\nfn test_failed_candidate_selection() {\n  ExtBuilder::default()\n    .with_balances(vec![(10, 10)])\n    .with_candidates(vec![(10, 10)])\n    .build()\n    .execute_with(|| {\n      roll_to(2);\n      assert_ok!(ParachainStaking::schedule_leave_candidates(Origin::signed(10), 6u32));\n      roll_to(5);\n      let candidate: Vec<u64> = ParachainStaking::selected_candidates();\n      assert_ne!(candidate[0], 10u64);\n    });\n}\n\nImpact: Collators will not be incentivized to ensure network stability. Another set of partially staked or “trusted” collators could provide better stability.\n\nRecommendation: Consider maintaining a set of “trusted” collators to fall back on if no staked collators can be found.\n\nDeveloper Response: Acknowledged.",
      "description_summary": "Unstaked users may be selected as collators if no sufficiently staked collators are available, reducing network stability.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "XCM instructions can charge 0 weight",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "runtime/calamari/src/weights/xcm/mod.rs",
          "lines": null
        },
        {
          "file_path": "runtime/dolphin/src/weights/xcm/mod.rs",
          "lines": null
        }
      ],
      "reported_impact": "Low",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Bad Extrinsic Weight",
      "vulnerability_class_scout": "Weight Management",
      "description": "4.1.12 V-MANC-VUL-012: XCM instructions can charge 0 weight\n\nSeverity: Low\nType: Bad Extrinsic Weight\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): runtime/(calamari, dolphin)/src/weights/xcm/mod.rs\nLocation(s): Every use of weigh_multi_assets\n\nThe Polkadot ecosystem uses the XCM messaging standard to enable parachains and the relay chain to communicate with each other. For example, if a parachain P1 wants to deposit an asset onto another parachain P2, they can construct an XCM message stating they wish to deposit an asset into an account associated with P1 and send it to P2.\n\nEach XCM message consists of a sequence of low-level XCM instructions that get executed by the XCM executor on the destination parachain. To offset the cost of executing these instructions, parachains set weights for each instruction, so the sender of the XCM message is charged fees for the destination parachain executing their message.\n\nManta Chain configured the weights of multiple instructions so that senders could generate messages with a total weight of 0. For example, in the code snippet below, the function deposit_asset sets the weight for the XCM instruction deposit_asset based on a parameter called assets. When assets is an empty vector, the weight_multi_assets function returns 0, resulting in a total weight of 0 for the instruction:\n\nfn deposit_asset(\n    assets: &MultiAssetFilter,\n    _max_assets: &u32,\n    _dest: &MultiLocation,\n) -> Weight {\n    let hardcoded_weight: u64 = 1_000_000_000;\n    let weight = assets.weigh_multi_assets(XcmFungibleWeight::<Runtime>::deposit_asset());\n    cmp::min(hardcoded_weight, weight)\n}\n\nThis setup allows malicious or incompetent senders to spam Manta with messages costing 0, even though the instruction is successfully executed by the XCM executor. While a denial of service may be unlikely due to the fast execution of 0-length vectors, spam prevention is recommended. Adding a minimal base fee for instructions that can be executed with 0 weight would help prevent spam.\n\nImpact: Malicious users may spam Manta with XCM messages of weight 0, potentially slowing down blockchain performance and risking denial of service.\n\nRecommendation: We recommend always charging a base fee to prevent spam.\n\nDeveloper Response: The developers acknowledged the issue and plan to change weigh_multi_assets to charge the benchmarked weight of a single asset execution for any successfully executed multiasset XCM message.",
      "description_summary": "XCM instructions can be executed with zero weight, allowing potential spam through 0-cost messages.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Missing validation in set_units_per_second",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/asset-manager/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Low",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Data Validation",
      "vulnerability_class_scout": "Error Handling and Validation",
      "description": "4.1.13 V-MANC-VUL-013: Missing validation in set_units_per_second\n\nSeverity: Low\nType: Data Validation\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): pallets/asset-manager/src/lib.rs\nLocation(s): set_units_per_second\n\nThe asset-manager pallet manages a hashmap called UnitsPerSecond which maps assetIds to a u128 value units_per_second, used to determine the price for an XCM transfer. It provides a function, set_units_per_second, to set the units_per_second for a given asset. This value determines the cost (in the corresponding asset) to purchase a certain weight for a transaction. The following code snippet calculates the amount:\n\nlet units_per_second = M::units_per_second(&asset_id).ok_or({\n    log::debug!(\n        target: \"FirstAssetTrader::buy_weight\",\n        \"units_per_second missing for asset with id: {:?}\",\n        id,\n    );\n    XcmError::TooExpensive\n})?;\n\nlet amount = units_per_second * (weight as u128) / (WEIGHT_PER_SECOND as u128);\n\nif amount.is_zero() {\n    return Ok(payment);\n}\n\nThis calculation of amount uses multiplication, which can overflow. Currently, both units_per_second and amount are of type u128. If units_per_second exceeds u128::MAX / u64::MAX, a large weight (u64::MAX) can be bought for a small asset amount, allowing a malicious parachain to potentially perform a DoS attack.\n\nThere is currently no validation in set_units_per_second to ensure units_per_second is small enough. Although only the root can call set_units_per_second, there is a risk if the root user mistakenly sets an excessive value or is tricked into doing so.\n\nImpact: If units_per_second is set above u128::MAX / u64::MAX, large amounts of weight can be purchased at low cost, potentially enabling a DoS attack on the chain.\n\nRecommendation: Change the type of units_per_second to map assetId to a u64 value or validate that the amount is sufficiently small.\n\nDeveloper Response: The developers acknowledged the issue and plan to fix the weight calculation to use saturating arithmetic, which should address this vulnerability.",
      "description_summary": "Missing validation in set_units_per_second allows potential overflow, enabling weight to be purchased at low cost, risking DoS.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Collator is a single point of failure for a round",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": null,
      "reported_impact": "Low",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Consensus",
      "vulnerability_class_scout": "Code Quality",
      "description": "4.1.14 V-MANC-VUL-014: Collator is a single point of failure for a round\n\nSeverity: Low\nType: Consensus\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nThe Manta parachain uses the Aura consensus mechanism to select collators to author blocks. Aura selects a primary collator for a round, and only that collator is allowed to produce blocks in that round. However, if that collator goes down, then no blocks will be produced, making that collator a single point of failure.\n\nOther parachains, like Moonbeam, address this by selecting multiple collators for a given round.\n\nImpact: If a collator goes down, no blocks will be produced for that round, thereby impacting the transaction throughput of Manta.\n\nRecommendation: We recommend that Manta adopt a consensus mechanism that selects multiple collators, ideally geographically separated, so if one collator fails, the likelihood of others failing remains low.\n\nDeveloper Response: The developers are aware of this issue and have plans to move away from the Aura consensus mechanism.",
      "description_summary": "Single collator selection creates a point of failure, risking block production halt if the collator goes down.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Unchecked index calculation in spend_all",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/manta-pay/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Warning",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Logic Error",
      "vulnerability_class_scout": "Arithmetic",
      "description": "4.1.15 V-MANC-VUL-015: Unchecked index calculation in spend_all\n\nSeverity: Warning\nType: Logic Error\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nFile(s): pallets/manta-pay/src/lib.rs\nLocation(s): spend_all\n\nThe spend_all function in the Manta-Pay pallet does the following:\n1. Adds the nullifier commitments in the TransactionPost to the NullifierCommitmentSet.\n2. Inserts each (nullifier, outgoingNote) pair into the NullifierSetInsertionOrder structure.\n3. Updates a global variable, NullifierSetSize, which stores the size of the nullifier commitment set.\n\nThe index where the pair gets inserted, along with the new nullifier size, is calculated as index + i, where i is the index of the corresponding SenderPost, and index is the current size of the set. However, this arithmetic is unchecked and could result in an overflow.\n\nImpact: When the size of the commitment set reaches u64::MAX, the index calculation may overflow, causing the pair to be inserted at the beginning of the list and setting the nullifier set size to 1. However, reaching this value through normal execution is extremely unlikely.\n\nRecommendation: Add an overflow check and return an error.\n\nDeveloper Response: TBD.",
      "description_summary": "Unchecked index calculation in spend_all may cause overflow, leading to incorrect data insertion.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Excess fees not refunded",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "parachain-staking/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Warning",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Bad Extrinsic Weight",
      "vulnerability_class_scout": "Weight Management",
      "description": "4.1.16 V-MANC-VUL-016: Excess fees not refunded\n\nSeverity: Warning\nType: Bad Extrinsic Weight\nFile(s): parachain-staking/lib.rs\nLocation(s): (cancel_leave, execute_leave, schedule_leave, join)_candidates\nCommit: 45ba60e1d\nStatus: Intended Behavior\n\nWhen a substrate extrinsic is created, its weight must be carefully considered to ensure it correctly reflects the computational cost of the operation as extrinsic weight is directly related to the fees that are charged to the user. This weight should capture the maximum number of computational resources that will be consumed by the extrinsic as excess fees can be returned. In several functions, though, the weights are computed based on the value of an argument provided by the user which might not always reflect the true cost of the computation.\n\nFor example, consider the following:\n\n1#[pallet::call_index(11)]\n2#[pallet::weight(<T as Config>::WeightInfo::cancel_leave_candidates(*candidate_count))]\n3/// Cancel open request to leave candidates\n4/// - only callable by collator account\n5/// - result upon successful call is the candidate is active in the candidate pool\npub fn cancel_leave_candidates(\n7origin: OriginFor<T>,\n8#[pallet::compact] candidate_count: u32,\n) -> DispatchResultWithPostInfo {\n...\n12let mut candidates = <CandidatePool<T>>::get();\n13ensure!(\n14candidates.0.len() as u32 <= candidate_count,\n15Error::<T>::TooLowCandidateCountWeightHintCancelLeaveCandidates\n);\n...\n18Ok(().into())\n}\n\nIn this function, the weight is computed using the candidate_count argument, and in order for the function to execute successfully, candidate_count must be greater than or equal to the current size of the candidate pool. A user might need to call this function with a candidate_count that is larger than the size of the pool to prevent a front-running attack where a malicious user would add candidates to prevent the transaction from executing successfully. In such a case, the weight would be larger than necessary, but no fees are returned to the user.\n\nImpact: Such functions can charge unnecessary fees to the user.\n\nRecommendation: Refund the user additional fees that are not consumed.\n\nDeveloper Response: Since these extrinsics are likely to be executed sparingly and since the additional fees are likely to be small, we feel like the additional computational cost of determining the excess does not.",
      "description_summary": "Extrinsics may charge unnecessary fees without refunding excess.",
      "reported_status": "Intended Behavior",
      "is_substrate_finding": true
    },
    {
      "title": "Assets can be registered at unsupported locations",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/asset-manager/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Warning",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Data Validation",
      "vulnerability_class_scout": "Error Handling and Validation",
      "description": "4.1.17 V-MANC-VUL-017: Assets can be registered at unsupported locations\n\nSeverity: Warning\nType: Data Validation\nFile(s): pallets/asset-manager/src/lib.rs\nLocation(s): register_asset\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nThe asset-manager pallet allows assets to be registered, managed, and minted. In particular, register_asset takes as input an asset, location, and corresponding asset_metadata and registers the asset. Every asset must be associated with a location; however, Manta only supports assets from specific locations. The current implementation of asset-manager does not perform any validation on the locations passed into register_asset, potentially allowing assets to be registered from untested locations. The pallet also exposes a method called update_asset_location, which is supposed to update the location of an asset. It similarly does not perform any validation on the new location of the asset.\n\nImpact: The current implementation allows assets to be registered from untested locations.\n\nRecommendation: The asset-manager pallet already implements the Contains trait, which exposes a method contains that takes as input a location and returns true if and only if the location is supported. Currently, that method is unused and can be used to validate the locations passed in.\n\nDeveloper Response: The developers acknowledged the issue and plan to add a check in register_asset.",
      "description_summary": "Assets can be registered without validating their location.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Minimum delegator funds is not MinDelegatorStk",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "parachain-staking/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Warning",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Logic Error",
      "vulnerability_class_scout": "Business Logic",
      "description": "4.1.18 V-MANC-VUL-018: Minimum delegator funds is not MinDelegatorStk\n\nSeverity: Warning\nType: Logic Error\nFile(s): parachain-staking/lib.rs\nLocation(s): N/A\nCommit: 45ba60e1d\nStatus: Acknowledged\n\nIn the case where MinDelegation < MinDelegatorStk, it is possible for the delegator’s staked funds to be less than MinDelegatorStk. This can occur through the following sequence of calls:\n\n1. delegate amount N from delegator D to candidate C1 where N >= MinDelegatorStk\n2. delegate amount M from delegator D to candidate C2 where M < MinDelegatorStk and M >= MinDelegation\n3. schedule_leave_candidates and execute_leave_candidates for C1\n\nThis results in D having M funds staked, where M < MinDelegatorStk.\n\nImpact: If MinDelegation is less than MinDelegatorStk, a delegator may end up with less than MinDelegatorStk funds actually staked.\n\nNote: This is not currently exploitable because MinDelegation == MinDelegatorStk in all production runtimes. However, if these values are adjusted in the future, this bug may become exploitable.\n\nRecommendation: There are two options:\n\n1. When starting a runtime, ensure that MinDelegation >= MinDelegatorStk\n2. Whenever a delegation is removed (such as in execute_leave_candidates), ensure that the remaining locked funds for the delegator are at least MinDelegatorStk.\n\nDeveloper Response: The developers acknowledged the issue and are considering removing MinDelegation as there is no apparent reason for it being different from MinDelegatorStk.",
      "description_summary": "Delegators can have staked funds below the required MinDelegatorStk.",
      "reported_status": "Acknowledged",
      "is_substrate_finding": true
    },
    {
      "title": "Unintended test crashes",
      "repository": "https://github.com/Manta-Network/Manta",
      "audited_commit": "45ba60e1d940dbf3491ce0f1223e44c84d5b7218",
      "reported_remediated_commit": null,
      "location": [
        {
          "file_path": "pallets/manta-pay/src/lib.rs",
          "lines": null
        }
      ],
      "reported_impact": "Info",
      "reported_likelihood": null,
      "cwe_classification": null,
      "vulnerability_class_audit": "Maintainability",
      "vulnerability_class_scout": "Code Quality",
      "description": "4.1.19 V-MANC-VUL-019: Unintended test crashes\n\nSeverity: Info\nType: Maintainability\nFile(s): pallets/manta-pay/src/lib.rs\nLocation(s): to_private_should_work\nCommit: 45ba60e1d\nStatus: Open\n\nMany of the manta-pay tests randomly generate an asset id, total supply, and an amount to make private. To ensure the total supply of the asset is greater than the minimum balance, the minimum balance is always added to the randomly generated total supply, as seen in this test:\n\nfn to_private_should_work() {\n  let mut rng = OsRng;\n  for _ in 0..RANDOMIZED_TESTS_ITERATIONS {\n    new_test_ext().execute_with(|| {\n      let asset_id = rng.gen();\n      let total_free_supply = rng.gen();\n      initialize_test(asset_id, total_free_supply + TEST_DEFAULT_ASSET_ED);\n      mint_private_tokens(\n        asset_id,\n        &value_distribution(5, total_free_supply, &mut rng),\n        &mut rng,\n      );\n    });\n  }\n}\n\nIf the random number generator generates a value for the total_free_supply which is greater than u128::MAX - TEST_DEFAULT_ASSET_ED, then the test will fail even though it is expected to succeed.\n\nImpact: May cause tests to fail when they are expected to succeed.\n\nRecommendation: Change the test to generate a value for total_free_supply between [0, u128::MAX - TEST_DEFAULT_ASSET_ED).\n\nDeveloper Response: TBD",
      "description_summary": "Randomized test may fail due to unintended overflow in total supply generation.",
      "reported_status": "Open",
      "is_substrate_finding": true
    }
  ]
}
